#ifndef LEADER_ZKWRAPPER_H_
#define LEADER_ZKWRAPPER_H_

#include <string>
#include <vector>
#include <functional>
#include <stdexcept>
#include <mutex>
#include <memory>
#include <map>
#include <thread>

#include "common/any.h"
#include "common/lock.h"

#ifndef zhandle_t
typedef struct _zhandle zhandle_t;
#endif

namespace leader {

template<typename T>
class ZKWrapperContext;

class ZKWrapper {
 public:
  /**
   * @brief ZKWrapper return code
   */
  typedef enum {
    ZK_OK,                  /*!< Everything is OK */
    ZK_NONODE,              /*!< Node does not exist */
    ZK_BADVERSION,          /*!< Version conflict */
    ZK_NODEEXISTS,          /*!< The node already exists */
    ZK_CONNECTIONLOSS,      /*!< Connection to the server has been lost */
    ZK_OPERATIONTIMEOUT,    /*!< Operation timeout */
    ZK_SYSTEMERROR,         /*!< OOM */
    ZK_BADARGUMENTS,        /*!< Bad arguments */
    ZK_INVALIDSTATE,        /*!< Invalid state */
    ZK_SESSIONEXPIRED,      /*!< Session expired by server*/
    ZK_UNDEFINED = 255
  } ZKCode;

  /**
   * @brief State of ZK connection
   */
  typedef enum {
    ZKSTATE_CONNECTING,
    ZKSTATE_CONNECTED,
    ZKSTATE_ASSOCIATING,
    ZKSTATE_EXPIRED_SESSION,
    ZKSTATE_AUTH_FAILED,
    ZKSTATE_UNDEFINED
  } ZKState;

  /**
   * @brief Watcher event type
   */
  typedef enum {
    ZKEVENT_CREATED,      /*!< This is only generated by watches on non-existent
                           *   nodes. These watches are set using Exists.*/
    ZKEVENT_DELETED,      /*!< This is only generated by watches on nodes.
                           *   These watches are set using Exists and Get.*/
    ZKEVENT_CHANGED,      /*!< This is only generated by watches on nodes.
                           *   These watches are set using Exists and Get.*/
    ZKEVENT_CHILD,        /*!< This is only generated by watches on the child
                           *   list of a node. These watches are set
                           *   using GetChildren.*/
    ZKEVENT_SESSION,      /*!< This is generated when a client loses contact
                           *   or reconnects with a server*/
    ZKEVENT_NOTWATCHING,  /*!< This is generated when the server for
                           *   some reason, probably a resource constraint,
                           *   will no longer watch a node for a client.*/
    ZKEVENT_UNDEFINED
  } ZKEvent;

  typedef struct {
    int64_t czxid = 0;    /*!< The zxid of the change that caused this znode to be created. */
    int64_t mzxid = 0;    /*!< The zxid of the change that last modified this znode. */
    int64_t ctime = 0;    /*!< The time in milliseconds from epoch when this znode was created. */
    int64_t mtime = 0;    /*!< The time in milliseconds from epoch when this znode was last modified. */
    int32_t version = 0;  /*!< The number of changes to the data of this znode. */
    int32_t cversion = 0; /*!< The number of changes to the children of this znode. */
    int32_t aversion = 0; /*!< The number of changes to the ACL of this znode. */
    int64_t ephemeralOwner = 0; /*!< The session id of the owner of this znode if the
                                 *   znode is an ephemeral node.
                                 *   If it is not an ephemeral node, it will be zero. */
    int32_t dataLength = 0;     /*!< The length of the data field of this znode. */
    int32_t numChildren = 0;    /*!< The number of children of this znode. */
    int64_t pzxid = 0;          /*!< The zxid of the change that last modified children of this znode. */
  } ZKStatus;

  typedef std::function<void(ZKCode, const char* pathOfCreatedNode)>
      StringCompleteLambda;
  typedef std::function<void(ZKCode, const ZKStatus*)> StatCompleteLambda;
  typedef std::function<void(ZKCode,
                             const char* data,
                             int dataLen,
                             const ZKStatus*)> DataCompleteLambda;
  typedef std::function<void(ZKCode, const char** stringArray, int arrayLen)>
      StringArrayCompleteLambda;
  typedef std::function<void(ZKCode, const char** stringArray,
                             int arrayLen, const ZKStatus*)>
      StringArrayStatCompleteLambda;
  typedef std::function<void(ZKCode)> VoidCompleteLambda;
  typedef std::function<void(ZKEvent,
                             ZKState,
                             const char* pathOfEventSourceNode)> WatcherLambda;

  /**
   * @brief ZKWrapper exception, wraps ZKCode inside
   */
  class ZKException : public std::runtime_error {
   private:
    ZKCode code_;
   public:
    explicit ZKException(ZKCode code) :
        std::runtime_error("ZK exception " + std::string(GetMessage(code))
                           + "(" + std::to_string(code) + ")"),
        code_(code) {}

    ZKCode code() const { return code_; }
  };

  /**
   * @brief Create a ZKWrapper instance
   * @param remote Comma separated host:port pairs, each corresponding to a zk
   *               server. e.g. "127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002"
   * @package watcher The global watcher callback function. When notifications are
   *                  triggered this function will be invoked.
   * @param recv_timeout The maximum amount of time in ms that can go by without
   *                     receiving anything from the zookeeper server
   */
  explicit ZKWrapper(const std::string& remote,
                     WatcherLambda&& watcher = nullptr,
                     int recv_timeout = 3000);

  /**
   * @brief Destructor, ZK connection will be closed if not closed by Shutdown
   */
  ~ZKWrapper();

  /**
   * @brief Reconnect to server, should be used when ZK_SESSIONEXPIRED
   * @throws ZKException Error happened during connect, may caused by OOM or network issue
   */
  void Connect();

  /**
   * @brief Shutdown ZK connection
   * @throws ZKException Error happened during shutdown, may caused by OOM or bad config
   */
  void Shutdown();

  /**
   * @brief all added callback will be called and removed once session updated
   * @param callback will be called on the thread Connect is called
   */
  void AddSessionUpdateCallback(std::function<void()>&& callback);

  /**
   * @brief Create node on provided path synchronously
   * @param path Path to node to create
   * @param value The data to be stored in the node.
   * @param valuelen The number of bytes in data.
   * @param ephemeral Create a ephemeral node(auto removed if session expires),
   *                  ephemeral node can't have children
   * @param sequence Create a sequence node
   * @param createdPath Path to created node will be saved to this
   *                    pointer, nullptr if not needed
   * @return ZK_OK operation completed successfully.<br/>
   *         ZK_NONODE the parent node does not exist.<br/>
   *         ZK_NODEEXISTS the node already exists.
   */
  ZKCode Create(const std::string& path,
                const char* value,
                int valuelen,
                bool ephemeral = false,
                bool sequence = false,
                std::string* createdPath = nullptr);

  /**
   * @brief Create node on provided path asynchronously
   * @param path Path to node to create
   * @param value The data to be stored in the node.
   * @param valuelen The number of bytes in data.
   * @param complete Complete lambda, path to created node will be passed as argument
   * @param ephemeral Create a ephemeral node(auto removed if session expires),
   *                  ephemeral node can't have children
   * @param sequence Create a sequence node
   * @return ZK_OK if request create success
   */
  ZKCode Create(const std::string& path,
                const char* value,
                int valuelen,
                StringCompleteLambda&& complete,
                bool ephemeral = false,
                bool sequence = false);

  /**
   * @brief Delete a node in zookeeper
   * @param path Path to the node
   * @param complete Complete lambda
   * @param version Expected version of the node, version mismatch during delete will
   *                return ZKBADVERSION
   * @return return code of the function call.<br/>
   *         ZK_OK operation completed successfully.<br/>
   *         ZK_NONODE the node does not exist.
   */
  ZKCode Delete(const std::string& path, int64_t version = -1);

  /**
   * @brief Delete a node in zookeeper asynchronously
   * @param path Path to the node
   * @param complete Complete lambda
   * @param version Expected version of the node, version mismatch during delete will
   *                return ZKBADVERSION
   * @return ZK_OK if request create success
   */
  ZKCode Delete(const std::string& path, VoidCompleteLambda&& complete,
                int64_t version = -1);

  /**
   * @brief Sets the data asssociated with a node synchronously
   * @param path Path to the node
   * @param buffer Buffer holding data to write
   * @param buflen Number of bytes from buffer to write
   * @param version Expected version of the node, version mismatch during write will
   *                return ZKBADVERSION
   * @param stat Status will be saved to this pointer,
   *             nullptr if no stat needed
   * @return return code of the function call.<br/>
   *         ZK_OK operation completed successfully.<br/>
   *         ZK_NONODE the node does not exist.
   */
  ZKCode Set(const std::string& path, const char* buffer, int buflen,
             int64_t version = -1, ZKStatus* stat = nullptr);

  /**
   * @brief Sets the data asssociated with a node asynchronously
   * @param path Path to the node
   * @param buffer Buffer holding data to write
   * @param buflen Number of bytes from buffer to write
   * @param complete Complete lambda
   * @param version Expected version of the node, version mismatch during write will
   *                pass ZKBADVERSION to @p complete
   * @return ZK_OK if request create success
   */
  ZKCode Set(const std::string& path, const char* buffer, int buflen,
             StatCompleteLambda&& complete, int64_t version = -1);

  /**
   * @brief Gets the data associated synchronously
   * @param path Path to the node
   * @param buffer The buffer holding the node data returned
   * @param bufferLen The size of the buffer pointed to by the buffer parameter.
   *                  It'll be set to the actual data length upon return.
   *                  If the data is nullptr, length is -1
   * @param stat Status will be saved to this pointer,
   *             nullptr if no stat needed
   * @param watch true if want to trigger global watcher on change
   * @return return code of the function call.<br/>
   *         ZK_OK operation completed successfully.<br/>
   *         ZK_NONODE the node does not exist.
   */
  ZKCode Get(const std::string& path, char* buffer, int* bufferLen,
             ZKStatus* stat = nullptr, bool watch = false);

  /**
   * @brief Gets the data associated synchronously
   * @param path Path to the node
   * @param buffer The buffer holding the node data returned
   * @param bufferLen The size of the buffer pointed to by the buffer parameter.
   *                  It'll be set to the actual data length upon return.
   *                  If the data is nullptr, length is -1
   * @param watcher One shot watcher lambda will be triggered on node change
   * @param stat Status will be saved to this pointer,
   *             nullptr if no stat needed
   * @return return code of the function call.<br/>
   *         ZK_OK operation completed successfully.<br/>
   *         ZK_NONODE the node does not exist.
   */
  ZKCode Get(const std::string& path, char* buffer, int* bufferLen,
             WatcherLambda&& watcher, ZKStatus* stat = nullptr);

  /**
   * @brief Gets the data associated asynchronously
   * @param path Path to the node
   * @param complete Complete lambda
   * @param watch true if want to trigger global watcher on change
   * @return ZK_OK if request create success
   */
  ZKCode Get(const std::string& path,
             DataCompleteLambda&& complete,
             bool watch = false);

  /**
   * @brief Gets the data associated asynchronously
   * @param path Path to the node
   * @param complete Complete lambda
   * @param watcher One shot watcher lambda will be triggered on node change
   * @return ZK_OK if request create success
   */
  ZKCode Get(const std::string& path, DataCompleteLambda&& complete,
             WatcherLambda&& watcher);

  /**
   * @brief Checks the existence of a node in zookeeper synchronously
   * @param path Path to the node
   * @param stat Status will be saved to this pointer,
   *             nullptr if no stat needed
   * @param watch true if want to trigger global watcher on change
   * @return return code of the function call.<br/>
   *         ZK_OK node exists.<br/>
   *         ZK_NONODE the node does not exist.
   */
  ZKCode Exists(const std::string& path,
                ZKStatus* stat = nullptr,
                bool watch = false);

  /**
   * @brief Checks the existence of a node in zookeeper synchronously
   * @param path Path to the node
   * @param stat Status will be saved to this pointer,
   *             nullptr if no stat needed
   * @param watcher One shot watcher lambda will be triggered on node change.
   *                The watch will be set even if the node does not exist.
   *                This allows clients to watch for nodes to appear.<br/>
   *                Watch exists on node can get ZKEVENT_CREATED ZKEVENT_DELETED ZKEVENT_CHANGED
   * @return return code of the function call.<br/>
   *         ZK_OK operation completed successfully.<br/>
   *         ZK_NONODE the node does not exist.
   */
  ZKCode Exists(const std::string& path,
                WatcherLambda&& watcher,
                ZKStatus* stat = nullptr);

  /**
   * @brief Checks the existence of a node in zookeeper asynchronously
   * @param path Path to the node
   * @param complete Complete function
   * @param watch true if want to trigger global watcher on change
   * @return ZK_OK if request create success
   */
  ZKCode Exists(const std::string& path,
                StatCompleteLambda&& complete,
                bool watch = false);

  /**
   * @brief Checks the existence of a node in zookeeper synchronously,
   *        or asynchronously if @p complete not nullptr
   * @param path Path to the node
   * @param complete Pointer to the complete lambda, ZKWrapper will takeover the memory
   *                 management of this object
   * @param watcher One shot watcher lambda will be triggered on node change.
   *                The watch will be set even if the node does not exist.
   *                This allows clients to watch for nodes to appear.<br/>
   *                Watch exists on node can get ZKEVENT_CREATED ZKEVENT_DELETED ZKEVENT_CHANGED
   * @return ZK_OK if request create success
   */
  ZKCode Exists(const std::string& path,
                StatCompleteLambda&& complete,
                WatcherLambda&& watcher);

  /**
   * @brief Get the children of a node synchronously
   * @param path Path to the node
   * @param children children will be saved to this pointer,
   *                 nullptr if not needed
   * @param watch true if want to trigger global watcher on change
   * @return the return code of the function.<br/>
   *         ZK_OK operation completed successfully.<br/>
   *         ZK_NONODE the node does not exist.
   */
  ZKCode GetChildren(const std::string& path,
                     std::vector<std::string>* children = nullptr,
                     ZKStatus* stat = nullptr,
                     bool watch = false);

  /**
   * @brief Get the children of a node synchronously
   * @param path Path to the node
   * @param children children will be saved to this pointer,
   *                 nullptr if not needed
   * @return the return code of the function.<br/>
   *         ZK_OK operation completed successfully.<br/>
   *         ZK_NONODE the node does not exist.
   */
  ZKCode GetChildren(const std::string& path,
                     std::vector<std::string>* children,
                     WatcherLambda&& watcher,
                     ZKStatus* stat = nullptr);

  /**
   * @brief Get the children and stat of a node asynchronously
   * @param path Path to the node
   * @param complete Complete function
   * @param watcher One shot watcher
   * @return ZK_OK if request create success
   */
  ZKCode GetChildren(const std::string& path,
                     StringArrayStatCompleteLambda&& complete,
                     WatcherLambda&& watcher);

  /**
   * @brief Set a new watcher lambda, old one will be replaced by this one
   * @param watcher New watcher lambda to set
   */
  void SetWatcher(WatcherLambda&& watcher);

  /**
   * @brief Get the client id of current zk session
   * @return
   */
  int64_t GetID();

  /**
   * @brief Get current state
   * @return ZKSTATE_UNDEFINED if not ShutDown() was called
   */
  ZKState GetState();

  static const char* GetMessage(ZKCode code);

  static std::string JoinPath(const std::string& path1,
                              const std::string& path2);

 private:
  template<typename U>
  friend class ZKWrapperContext;

  static void GlobalZooWatcher(zhandle_t*, int, int, const char*, void*);

  template<typename T>
  void RemoveContext(const std::shared_ptr<T>& context);

  void RemoveContextById(uint64_t id);

  template<typename T>
  uint64_t AddContext(std::shared_ptr<T> context);

  zhandle_t* zhandle_ = nullptr;
  int zrecv_timeout_ = 0;
  std::string zremote_;
  common::ReadWriteLock watcher_lock_;
  common::ReadWriteLock zhandle_lock_;
  WatcherLambda watcher_;
  std::mutex context_pool_mutex_;
  std::map<uint64_t, common::any> context_pool_;
  uint64_t context_id_count_;

  std::mutex finalize_thread_mutex_;
  std::thread finalize_thread_;
  std::mutex session_update_callback_mutex_;
  std::vector<std::function<void()>> session_update_callbacks_;
};

}  // namespace leader

#endif  // LEADER_ZKWRAPPER_H_
